.Dd $Mdocdate$
.Dt redo 1
.Os
.
.Sh NAME
.
.Nm redo ,
.Nm redo-ifchange ,
.Nm redo-ifcreate ,
.Nm redo-infofor
.Nd rebuild target files when source files have changed
.
.Sh SYNOPSIS
.
.Nm redo
.Op Fl j Ar n
.Ar target...
.
.Nm redo-ifchange
.Op Fl j Ar n
.Ar target...
.
.Nm redo-ifcreate
.Ar target...
.
.Nm redo-infofor
.Ar target...
.
.Sh DESCRIPTION
.
(This manual page describes the
.Nm baredo
implementation)

The
.Nm
build system is useful for creating targets and updating them when their sources get
changed. It is implemented via the
.Nm redo ,
.Nm redo-ifchange ,
.Nm redo-ifcreate
programs.

The
.Nm redo-infofor
program prints the information that
.Nm redo
has stored, for targets it has created, in a human readable format. This
format is described in the
.Sx BUILD INFO
section.

Flags recognized:
.br
.Fl j Ar n
.
.Bd -ragged -offset indent -compact
.
When
.Ar n
is positive, run jobs in parallel, at most
.Ar n
at a time.

When
.Ar n
is 0, run as many jobs as the job manager is able to handle.

When
.Ar n
is not 1, children
.Nm redo
instances will ignore their
.Fl j
flag, and currently there is no way provided to make a
.Nm redo
instance behave independently from a running job manager.
.Ed
.
.Sh PRODUCING A TARGET
.
The procedure
.Nm redo
follows for producing a target comprises of
.
.Ss finding a .do file for the target
.
Example of the search with dir/trg.a.b as target:
.D1 dir/trg.a.b.do
.D1 dir/default.a.b.do
.D1 dir/default.b.do
.D1 dir/default.do
.D1 default.a.b.do
.D1 default.b.do
.D1 default.do
.D1 (then default*.do-s are tested in parental directories up to /)
The search ends when one is found and only depends on the target file's path.

When a .do file's existence is checked, implicit dependencies are added to the
current target: dependencies on the inexistence of those that didn't exist
and on the state of the .do file that was found and used to produce it.

If no .do file is found,
.Nm redo
reports failure and aborts.
.
.Ss executing the found .do file
.
A .do file is executed with cwd (current working directory) set to the directory
it is in, its stdout (standard output) is redirected to an empty file and 3
arguments are passed to it:
.br
($1, $2, $3 denote the first, second and third argument passed)
.
.Bd -ragged -offset indent
.
$1: a path, relative to the .do file's cwd, to the target the .do
file is called to produce.

$2: same as $1 but without the suffix that was used to match the found .do
file. It is different from $1 only when the matched .do file is like
default.*suf.do, in which case $1 == $2.*suf.

$3: a path to a file that does not yet exist, read below for its usage.

.Ed
.
Some examples:
.
.Bd -ragged -offset indend
.
.TS
tab(|);
l|l.
target|/path/to/name
\&.do file|/path/to/name.do
$1|name
$2|name
$3|name.redo.RANDSUF
.TE

.TS
tab(|);
l|l.
target|/path/to/dir/name.a.b
\&.do file|/path/to/default.a.b.do
$1|dir/name.a.b
$2|dir/name
$3|dir/name.a.b.redo.RANDSUF
.TE

.TS
tab(|);
l|l.
target|/path/to/dir/name.a.b
\&.do file|/path/to/default.b.do
$1|dir/name.a.b
$2|dir/name.a
$3|dir/name.a.b.redo.RANDSUF
.TE
.
.Ed

If the .do file returns non-zero status, then
.Nm redo
aborts and returns non-zero.
If
.Nm redo
receives SIGINT while the .do file is running, only minimal cleanup is performed
before aborting, so that any .do file's output can be inspected. Running
.Dl "$ find . -type f -name '*.redo.*'"
can be used to list (at least) those remaining temporary files.
.
.Ss declaring dependencies of the current target
.
During its execution, a .do file may call
.
.Bd -ragged -offset indent -compact
.
.Nm redo-ifchange
.Ar targets...
.br
.Nm redo
.Ar targets...
.
.Bd -ragged -offset indent -compact
.
in which cases it is marked that the current target depends on target's state
and
.
.Bl -bullet -compact
.
.It
.Nm redo-ifchange
.br
will try to create/update target if it doesn't exist or is out-of-date, while
.It
.Nm redo
.br
will try to create/update target, even if it is up-to-date or was not build by
.Nm redo .
.
.El

Also,
.Nm redo-ifchange
will refuse to update a target if it has been modified since
.Nm redo
build it, in order to protect contents generated by other means. If you want to
have it treated as a source file you need to remove its stored build-info file
(see the
.Sx BUILD INFO
section for details). If you want to have it treated as a target, either remove
it or use the
.Nm redo
command instead.
.
.Ed
.
.Nm redo-ifcreate
.Ar targets...
.D1 in which case it is marked that the current target depends on the inexistency \
of each target in targets (so it should get updated when at least one of them gets \
created).
.
.Ed

.Nm redo
is able to detect dependency cycles (since it does not know the complete dependencies'
graph) as long as only one
.Nm redo
instance is working with targets on a graph.
.
.Ss creating the target
.
A .do file may write to its stdout or create $3 (but may not do both or affect
$1 directly, errors which
.Nm redo
detects).

Otherwise,
.Bl -bullet -offset m -compact
.
.It
if it wrote to its stdout, then the file to which its stdout is redirected
.It
or, if it created $3, then $3
.
.El
atomically replaces $1.

If it did neither, $1's status is unchanged, but if $1 exists then its
build-info will get updated, so even if it was not actually updated it will
be considered as up-to-date.
.
.Ss storing information about the created target
.
(This is not done when the target doesn't exist, since inexistent targets are
always out-of-date)

This is described in the
.Sx BUILD INFO
section below.
.
.Sh BUILD INFO
.
For every target it creates,
.Nm redo
stores necessary information in a build-info file inside
a local .redo/ directory.

Examples for the location of the build-info file:

.TS
tab(|);
l l
_ _
l l.
target|build-info file
dir/name.suf|dir/.redo/name.suf.bi
dir/other/name|dir/other/.redo/name.bi
.TE

Using separate .redo/ directories instead of one "global" is important because
a build-info file can be only in one place (there would be problems if duplicates
could exist) and its location only depends on the target. As a result, a target
can be kept up-to-date independently of what requires it.

.Nm redo
uses the build-info files to store:
.
.Bl -bullet -compact
.
.It
target's inode number and mtime (modification time),
.It
every ifchange dependency's inode number, mtime and its
path relative to target,
.It
every ifcreate dependency's path relative to target,
.
.El

which
.Nm redo-infofor
prints in the following way:
.TS
tab(|);
l l l l l.
:|inode number|mtime sec|mtime nsec|target's last path component
\&=|inode number|mtime sec|mtime nsec|path relative to target
.TE
.TS
tab(|);
l l.
-|path relative to target
.TE
.br
(the dependencies' order is unimportant)

A target is considered up-to-date as long as
.Bl -bullet -offset m -compact
.
.It
every ifchange dependency's inode number and mtime are the same as the
ones stored in the target's build-info file and
.It
none of its ifcreate dependencies exist.
.
.El
.
.Sh ENVIRONMENT
.
.Ev REDO_FSYNC
.Bd -ragged -offset indent -compact
.
.TS
tab(|);
l l.
Value|Behaviour
0|don't call fsync(2)
1|call fsync(2)
.TE
(by default,
.Nm redo
acts as if REDO_FSYNC=1)

Can be used to control whether
.Nm redo
explicitly calls
.Xr fsync 2 .
By default, and unless REDO_FSYNC == 0, it does so to ensure the atomicity of some
operations (e.g. $1's creation).
.
.Ed
.

.Nm redo
instances also use various environmental variables prefixed with _REDO (like
_REDO_LEVEL) for communication between them.
.
.Sh EXAMPLES
.
Example scripts for building a C program `prog` which consists of prog.c, util.c and
util.h source files:
.Bd -literal
(scripts' names and contents are presented in the following way:
name:
	file's contents
	contents...
.Ed
)
.
.Bd -literal -offset indent
all.do:
	redo-ifchange prog

prog.do:
	redo-ifchange cc objfs
	redo-ifchange $(cat objfs)

	./cc -o "$3" $(cat objfs)

cc: (executable)
	#!/bin/sh

	cc=cc
	cflags='-std=c99 -Wall -Wpedantic -O2'
	ldflags='-lm'

	$cc $cflags $ldflags "$@"

objfs.do:
	redo-ifchange srcfs
	while read -r srcf
	do
		printf '%s\\n' "${srcf%.c}.o"
	done < srcfs

srcfs:
	prog.c
	util.c

default.o.do:
	redo-ifchange "$2.c" "$2.deps"
	redo-ifchange $(cat "$2.deps")

	./cc -c -o "$3" "$2.c"

prog.deps:
	util.h

util.deps:
	util.h
.Ed

To have the source files in src/ and the generated .o's in obj/, we can modify
the default.o.do and the objfs.do files, as follows:
.
.Bd -literal -offset indent
objfs.do:
	redo-ifchange srcfs
	while read -r srcf
	do
		printf '%s\\n' "obj/${srcf%.c}"
	done

default.o.do:
	bnm=${2#*/}
	srcf=src/$bnm.c
	depsf=src/$bnm.deps # the .deps files are moved
	                    # to src/ as well

	redo-ifchange "$srcf" "$depsf"
	(
		# paths contained in .deps are relative to its
		# location or absolute
		cd "${srcf%/*}"
		redo-ifchange $(cat "$OLDPWD/$depsf")
	)
	./cc -c -o "$3" "$srcf"
.Ed
.
.Sh SEE ALSO
.
.Xr sh 1
.
.Sh HISTORY
.
.Nm redo
has been originally designed by Daniel J. Bernstein, which describes at
https://cr.yp.to/redo.html, as a safer, more efficient alternative to make(1)
that makes specifying dependencies correctly straightforward.
